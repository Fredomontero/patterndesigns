<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Pattern Designs</title>
</head>
<body>
    <style>
        body{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0095b6;
            padding: 4%;
        }

        h1{
            color: #fff;
        }

        .item{
            background-color: #fff;
            border-radius: 10px;
            padding: 1%;
            margin: 10px 0;
        }

    </style>
    <h1>Pattern designs</h1>
    <div class="item">
        <h2>Constructor pattern</h2>
        <p>
            A constructor is a special method used to initialize a newly created object once memory has been allocated for it. In javascript as almost everything is an object
            we're most often interested in object constructors.
            Object constructors ar eused to create specific types of objects - both preparing the object for use and accepting arguments which a constructor can use to set the values of
            member properties and methods when the object is first created.
        </p>
    </div>

    <div class="item">
        <h2>Constructor with prototypes Pattern</h2>
        <p>
            When an object is created, its definition is inherited froma  prototype. Weirdly, each prototype is also an object, so even prototypes  have prototypes. Except 
            for object, which is the top-level prototype. The advantage to attaching functions to the prototypes is that only a single copy of the function is created; saving
            on memory.
        </p>
    </div>

    <div class="item">
        <h2>Module Pattern</h2>
        <p>
            Modules are an integral piece of any robust application's architecture and typically help in keeping the units of code for a project both cleanly separated and organized.
            The module pattern was originally defined as a way to provide both private and public encapsulation for classes in conventional software engineering. In javascript, the module
            pattern is used for futher emulate the concept of classes in such a way that we're able to include both public/private variables inside a single object, thus shielding
            particular parts from the global scope. What this results in a reduction in the likelihood of our function names conflicting with other functions defined in additional scripts
            on the page.
            <br>
            The module Pattern encapsultaes "privacy", state and organization using closures. It provides a way of wrapping a mix of public and private methods and variables, protecting pieces
            from leaking into the global scope and accidentally colliding with another developer's interface. With this patter we only return what we want and keep everything else within
            the closure private. So, as we know in a way since variable can't technically be declared as being public nor private we use the function scope to emulate this concept.
        </p>
    </div>

    <div class="item">
        <h2>Singleton Pattern</h2>
        <p>
            The singleton Pattern is thus known because it restricts instantiation of a class to a single object. Classically the Singleton Pattern can be implemented by creating a class
            with a method that creates a new instance of the class if one doesn't exist. In the event of an instance already existing, it simply returns a reference to that object.
        </p>
    </div>

    <div class="item">
        <h2>Observer Pattern</h2>
        <p>
            The observer is a design Pattern where an object (known as a subject) mantains a list of objects depending on it (observers), automatically notifying them of any changes to state.
            When a subject need to notify observers about something interesting happening it broadcast a notification to the observers (which can include specific data related to the topic
            of the notification). When we no longer wish for a particular observer to be notified of the changes  by the subject  they are registered with, the subject can remove them from
            the list of observers.
        </p>
    </div>

    <div class="item">
        <h2>Publish/Subscriber Pattern and differences between them </h2>
        <p>
            <ul>
                <li>
                    The Observer Pattern requires that the observer (or object) wishing to recieve topic notifications must subscribe this interest to the object firing the event (the subject).
                </li>
                <li>
                    The Publish/subscribe Pattern however uses a topic/Event channel which sits between the objects wishing to recieve notifications (subscribers) and the object firing the 
                    event (The publisher). This event system allows code to define application specific events which can pass custom arguments containing values needed by the subscriber. The idea
                    here is to avoid dependencies between the publisher and the subscriber.
                    <br>
                    This differs from the Observer Pattern as it allows any subscriber implementing an appropiate event handler to register for and recieve topic notifications broadcast by the publisher.
                </li>
            </ul>
            <h3>Advantages and disadvantages</h3>
            <ul>
                <li>
                    The observer and Publisher/subscriber Patterns encourage us to think hard about  the relationships between different parts of our application. They also help us identify
                    what layers containing direct relationships which could be replaced with sets of our subjects and observers. This effectively could be used to break down an application
                    into smaller, more loosely coupled blocks to improve code management and potential for reuse.
                </li>
                <li>
                    A draw-back of the publisher/subscriber pattern is that subscribersare quiet ignorant  to the existence of each other and are blind to the cost of switching publishers.
                    Due to the dynamic relationship between subscribers and publishers, the update dependency can be difficult to track.                    
                </li>
                <li>
                    Implementation: https://www.youtube.com/watch?v=5wylV5in9qg
                </li>
            </ul>
        </p>
    </div>

    <div class="item">
        <h2>The mediattor Pattern</h2>
        <p>
            A real world anology of teh mediattor Pattern could be a typical airport traffic control system. A tower (Mediator) handles whta planes can take off  and land because all
            communications (notifications being listened out for our boradcast) are done from the planes to the control tower, rather than from plane to plane. A centralized controller 
            is key to success of this system and that's really the role mediator plays in software design.
        </p>
        <b>Implementation: https://www.dofactory.com/javascript/mediator-design-pattern</b>
    </div>

    <div class="item">
        <h2>The Prototype Pattern</h2>
        <p>
            The GoF refer to the prototype pattern as one which creates objects based on a template of an existinf object through cloning. 
            We can think of the prototype Pattern as being based on prototypal inheritance where we create objects which act as prototypes for
            other objects. The prototype object itself is effectively used as a blueprint for each object the constructor creates. If the prototype
            of the constructor function used contains a property called name for example, then each object created by the same constructor will also
            have this same property. <br>
            Reviewing the definitions for this pattern in existing literature, we may find references to classes once again. The reality is that prototypal
            inheritance avoids using classes altogether. There isn't a deifnition object nor a core object in theory. We're simply creatung copies of
            existing functional objects.
        </p>
    </div>

    <div class="item">
        <h2>The Command Pattern</h2>
        The command pattern aims to encapsultae method invocation, request or operations into a single object and gives us the ability to both parameterize
        and pass method calls around that can be executed at our discretion. In addition, it enables us to decouple objects invoking the action from other 
        objects which implement them. giving us a greater degree of overall flexibility in swapping out cocrete classes.
    </div>

    <div class="item">
        <h2>The Facade Pattern</h2>
        This pattern provides a convenient higher-level interface to a larger body of code, hiding its true complexity. Think of it as simplifying the API
        being presented to other developers, something which almost always improves usability.
    </div>

    <div class="item">
        <h2>The Factory Pattern</h2>
        The Factory Pattern is another creational pattern concerned with the notion of creating objects. where it differs from the other patterns in
        it's category is that it doesn't explicitly require us to use a contructor instead, a factory pattern can provide a generic interface for 
        creating objects we can specify the type of factory object we wish to be created.
        <h3>When to use the factory Pattern</h3>
        <ul>
            <li>When our object or component setup involves high level of complexity</li>
            <li>When we need to easily generate different instances of objects depending on the environment we are in</li>
            <li>When we're working with many small objects or components that share the same properties</li>
            <li>When composing objects with instances of other ojects that need only satisfy an API contract to work. This is useful for decoupling</li>
        </ul>
        <h3>When not to use it</h3>
        <ul>
            when applied to the wrong type of problem, this pattern can introduce an unnecessarily great deal of complexity to an application, 
            Unless providing an interface for object creation is a design goal for the library or framework we are writing, I would suggest sticking to
            explicit constructors to avoid the unnecesary overhead.
        </ul>
    </div>

    <div class="item">
        <h2>The Mixin Pattern</h2>
        <h4>Sub-classing:</h4>
        Is a term that refers to inheriting properties for a new object from a base or supperclass object. In traditional object-oriented programming, 
        a class B is able to extend another class A. Here we consider A a superclass and B subclass of A. As such, all instances of B inherit the methods
        from A, B is however still able to define it's own methods, including those that overrides methods originally defined by A.
        <h4>Mixins</h4>
        Mixins allow objects to borrow (or inherit) functionality from them with a minimal amount of complexity. As the pattern works well with Javascript
        object prototypes, it gives us a fairly flexible way to share functionality from not just one Mixin, but effectively many through multiple inheritance.
        They can be viewed as objects with attributes and methods that can be easily shared across a number of other objects prototypes.
    </div>

    <div class="item">
        <h2>The Decorator Pattern</h2>
        
    </div>



    <div class="item">
        <p>
            Constructor Pattern [X]<br/>
            Constructor with prototypes Pattern [X]<br/>
            Modules Pattern [X]<br/>
            Singleton Pattern [X]<br/>
            Observer Pattern [X]<br/>
            Publisher/Subscriber [-]<br/>
            Mediator Pattern [-]<br/>
            Prototype Pattern [-]<br/>
            Command Pattern [?]<br/>
            Facade Pattern [-]<br/>
            Factory Pattern [X]<br/>
            Mixins Pattern [-]<br/>
            Decorator Pattern []<br/>
            MVC Pattern []<br/>
            MVP Pattern []<br/>
            MVVM Pattern []<br/>
            AMD Pattern []<br/>
        </p>
    </div>
    
</body>
</html>